## Redis 消息队列与发布订阅

### 目录

- [生产者消费者模式](#生产者消费者模式)

  - [push/pop 机制](#push/pop-机制)

  - [队列空了怎么办](#队列空了怎么办)
  - [延时队列](#延时队列)

- [发布者订阅者模式](#发布者订阅者模式)
  
  - [PubSub](#pubsub)
  
  - [实现](#实现)
  
    - [频道订阅与退订](#频道订阅与退订)
  
    - [模式订阅与退订](#模式订阅与退订)
  
    - [发送消息](#发送消息)



Redis 实现消息队列有两种模式：

- 生产者消费者模式：每个消息只能被一个消费者消费，即不支持消息的多播机制。
- 发布者订阅者模式：每个消息可以被发送给多个订阅者，支持消息的多播机制。



### 生产者消费者模式

#### push/pop 机制

Redis 的异步消息队列使用 list 数据结构。

生产者：用 rpush 和 lpush 操作入队列，生产消息。

消费者：用 lpop 和 rpop 操作出队列，消费消息。



缺点：

这种方案过于简单，消息没有状态，且没有 ACK 机制，不适合用于对消息的可靠性要求较高的场景。



#### 队列空了怎么办

客户端通过队列的 pop 操作来获取消息，然后进行处理，处理完在获取消息，再进行处理，如此循环。

如果队列空了，则会陷入不停的 pop 而没有数据，这是浪费时间生命的「 空轮询 」。

空轮询存在的问题：

- 拉高客户端的 CPU 消耗。
-  拉高 Redis 的 QPS ，Redis 的慢查询会增多。



如何解决？

使用 sleep，让线程睡一会。

问题：睡眠会导致消息的延迟增大。



使用阻塞读指令 「 blpop / brpop 」。

阻塞读在消息队列没有数据的时候会立即进入休眠状态，一有数据就立即醒过来。

问题：空闲连接问题。如果线程一直阻塞在那里，Redis 客户端的连接就成了闲置连接，闲置过久，服务器会主动断开连接，这个时候 blpop / brpop 会抛出异常。

需要捕获到异常，然后重试。



#### 延时队列

延时队列可以通过 sorted set 实现。

将消息序列化成一个 sorted set 的 value，这个消息的到期时间作为 score，然后用多个线程轮询 sorted set 获取到期的任务进行处理。

多个线程是为了保障可用性，一个线程挂了还有其他线程可以处理。

因为有多个线程，所以就要考虑并发争抢任务，确保任务不会被多次执行。

使用 Redis 的「 zrem 」来保证任务不会被多个线程争抢。

[Redis学习笔记之延时队列](https://blog.csdn.net/u014427391/article/details/87905450)



### 发布者订阅者模式

使用 Redis 的 PubSub 机制。

#### PubSub

Redis PubSub 的发布者和订阅者是不同的连接，需要两个 Redis 连接，一个发布消息，一个订阅消息。

在生产环境中，应该将发布者和订阅者放在不同线程里，必须先启动订阅者，再执行发布者。



问题：

PubSub 的订阅者如果用休眠的方式来轮询消息，也会有消息处理不及时的问题。

可以使用 listen 阻塞监听消息来进行处理，同 blpop/brpop 原理一样。



##### 缺点：

- 当消费者挂掉重新连上的时候，在断连期间发布者发布的消息，该消费者就接收不到了。
- 如果 Redis 停机重启，**消息不会持久化**。Reids 宕机相当于一个消费者都没有，所有的消息就会被直接丢弃。



Redis 5.0 新增了 Stream 数据结构，这个功能给 Redis 带来了持久化消息队列。

[求不更学不动之Redis5.0新特性Stream尝鲜](https://juejin.im/post/5b10ad586fb9a01e4072a520#comment)



#### 实现

#####  频道订阅与退订

###### 频道订阅

Redis 将所有频道的订阅关系都保存在服务器状态的「 pubsub_channels 」字典里。字典的键是被订阅的频道， 键的值则是一个链表，链表中保存了所有订阅这个频道的客户端。

客户端通过指令「 SUBSCRIBE 」订阅一个或多个频道 「 channel 」。

- 如果频道已有订阅者，将客户端添加至订阅者链表末尾；
- 如果频道还未有订阅者，那么在 pubsub_channels 字典中不存在该频道的键，需要在 pubsub_channels 字典中为该频道添加一个键，并将这个键的值设置为空链表，然后将客户端添加至链表中。



###### 频道退订

使用 「 UNSUBSCRIBE 」为客户退订频道。

- 通过频道名称在 pubsub_channels 字典里查找到对应的订阅者链表，从订阅者链表中删除客户端；
- 如果退订后订阅者链表为空链表，则说明该频道没有订阅者了，就从 pubsub_channel 中删除该频道对应的键。



##### 模式的订阅与退订

客户的可订阅某个或多个模式，当有消息发送给某个频道时，消息不仅发送给订阅了该频道的订阅者，还会发送给与这个频道匹配的的模式的订阅者。

###### 模式订阅

所有模式的订阅关系保存在「 pubsub_patterns 」中。pubsub_patterns 是一个链表，链表中的每个节点都是一个 「 pubsubPattern 」结构，这个结构的 pattern 属性记录了被订阅的模式，client 属性记录了订阅者。

客户端通过指令「 PSUBSCRIBE」订阅某个或多个模式。

- 新建一个 pubsubPattern 结构，pattern 属性设置为被订阅的模式，client 属性设置为订阅的客户端；
- 将 pubsubPattern 结构添加到 pubsub_patterns 链表的末尾。



###### 退订模式

通过指令 「 PUNSUBSCRIBE 」退订模式。

服务器在 pubsub_patterns 链表中查找并删除 pattern 属性为要退订的模式，并且 client 属性为要退订模式的客户端的 pubsubPattern 的结构。



##### 发送消息

调用 「 PUBLISH <channel> <message> 」命令将 message 发送给 channel 的订阅者。

首先根据 channel 定位到字典的键， 然后将信息发送给值上订阅者链表中的所有客户端。

当使用 PUBLISH 命令发送信息到某个频道时， 不仅所有订阅该频道的客户端会收到信息， 如果有某个/某些模式和这个频道匹配的话， 那么所有订阅这个/这些频道的客户端也同样会收到信息。

PUBLISH 命令会遍历整个 pubsub_patterns 链表，查找与 channel 相匹配的模式，然后将消息发送给订阅了模式的客户端。



相关文章：

[Redis 设计与实现 - 订阅与发布](https://redisbook.readthedocs.io/en/latest/feature/pubsub.html)



### 参考

- 《Redis 深度历险 核心原理与应用实践》钱文品
- 《Redis 设计与实现 第二版》黄建宏







