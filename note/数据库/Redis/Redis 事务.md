## Redis 事务

### 目录

- [事务的实现](#事务的实现)
- [事务的错误](#事务的错误)
- [watch 机制](#watch-机制)
- [事务的 ACID 性质](#事务的-acid-性质)

相关命令：

- 「 MULTI 」 命令指示事务的开始
- 「 EXEC 」命令指示将事务提交给服务器执行
- 「 DISCARD 」命令执行事务的丢弃



#### 事务的实现

三个阶段：

- 事务开始
- 命令入队
- 事务执行



所有指令在 EXEC 之前不执行，先缓存在服务器的一个事务队列中，一旦收到 EXEC 指令才开始按先进先出（FIFO）的顺序执行事务队列，执行完毕后一次性返回所有指令的允许结果。



### 事务中的错误

- 入队错误：即是命令错误，服务器会对命令入队失败的情况进行记录，并在客户端调用 EXEC 命令时，拒绝执行并自动放弃这个事务，后面的命令不会执行。

- 执行错误：即使事务中有某个/某些命令在执行时产生了错误， 事务中的其他命令仍然会继续执行。



### watch 机制

使用 「 WATCH 」命令，它是一种乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。

可以在 EXEC 命令之前监视一个或多个数据库键，检查被监视的键是否至少有一个被修改或删除，如果是，服务器拒绝执行事务，并返回 NULL 告知客户端事务执行失败。



注意：

WATCH 命令要在 MULTI 命令之前执行。



### 事务的 ACID 性质

在 Redis 中事务**总是具有原子性 ( Atomicity )，一致性 ( Consistency )，隔离性 ( Isolation )**，当 Redis 运行于 AOF 持久化机制下，并且 appendfsync 选择配置为 always 时，事务也具有持久性 ( Durability)。



#### 原子性

上面讲到了事务的两种错误，

一种是因为命令入队出错而被服务器拒绝执行，事务中的所有命令都不会执行。

另一种即使事务队列中的某个命令在执行期间发生错误，整个事务还是会继续执行下去。因为 Redis 事务与其他关系型数据库的事务不同的是，**Redis 不支持事务的回滚机制**。

> 不支持事务回滚是因为这种复杂的功能与 Reids 追求简单高效的设计主旨不符，并且 Reids 事务的执行错误通常是因为编程错误产生的，这种错误很少在生产环境中产生，因此没有必要为 Redis 开发事务回滚功能。



#### 一致性

Redis 通过错误检测和简单的设计来保证事务的一致性。

三个 Redis 事务可能出错的地方，不会对一致性产生影响：

- 服务器拒绝执行入队过程中出现错误的事务，因此不会对一致性产生影响。
- 事务执行过程中的错误不会对数据库做任何修改，因此不会对一致性产生影响。
- 如果 Redis 在执行事务的过程中宕机了，根据 Redis 的持久化机制，不会对一致性产生影响。



#### 隔离性

Redis 使用单线程执行事务，并且服务器保证在事务执行过程中不会对事物进行中断，因此 Reids 事务总是以串行的方式运行，具有隔离性。



#### 持久性

Redis 事务的持久性依据 Reids 所使用的持久化模式。

- 如果服务器运行在无持久化模式下，Redis 事务不具备持久性。
- RDB 持久化模式下，服务器只会在特定的 save 条件被满足时，才执行 BGSAVE 命令进行数据保存，并且异步执行的 BGSAVE 不能保证事务数据第一时间被保存到硬盘里，因此在 RDB 模式下 Redis 事务不具备持久性。
- 当运行在 AOF 模式下，并且 appendfsync 选项的设置为 always 时，程序总会将命令保存到硬盘里，因此这种配置下的持久化模式具有持久性，其他配置选项不具备持久性。



相关文章：

[Redis 事务](http://redisdoc.com/topic/transaction.html)