## Redis 过期删除策略和内存淘汰策略

### 目录

- [过期删除策略](#过期删除策略)

  - [惰性删除策略](#惰性删除策略)
  - [定期删除策略](#定期删除策略)

- [内存淘汰策略](#内存淘汰策略)

  - [LRU 算法](#lru-算法)
  
  

### 过期键判定

Redis 会将设置了过期时间的键放入一个独立的过期字典中。

如果键存在于过期字典中，那么取得过期时间，判断过期时间是否大于当前 UNIX 时间戳。



### 过期删除策略

通常有定时删除、惰性删除和定期删除三种过期策略。

Redis 采用「 惰性删除 + 定期删除 」的过期策略



#### 惰性删除策略

被动删除策略。每次获取键的时候检查键是否过期，如果过期就删除键，如果没有过期就返回键。

**优点**：

对 CPU 来说是最友好的，只有在取键的时候才对键进行过期检查，不会在删除其他无关键上花费 CPU 时间。



**缺点**：

对内存来说最不友好，有可能存在大量过期的键没有被访问到而没有被删除，浪费内存空间，有内存泄漏的危险。



#### 定期删除策略

主动删除策略。每隔一段时间进行过期扫描，删除过期键。



- 通过限制删除操作所执行的时长和频率来减少删除操作对 CPU 时间的影响。
- 通过定期删除过期键，有效减少因为过期键带来的内存浪费。



定期删除策略的难点是确定删除操作的时长和频率：

- 如果删除操作执行时间太长，或者太频繁，定期删除策略就会退化成定时删除策略，以至于将 CPU 时间过多地消耗在删除键上面。
- 如果删除操作执行时间太短，或者太少，将退化成惰性删除策略，出现内存浪费的情况。



实现：

- Reids 默认每秒进行 10 次**过期扫描**，过期扫描不会遍历所有过期键，而是采用一种简单的贪心策略：

  1. 从过期字典中随机选出 20 个键。

  2. 删除这 20 个键中过期的键。

  3. 如果过期比例超过 1/4 ，那就重复步骤 1。

- 为了保证不会出现循环过度，导致线程卡死，扫描时长默认不会超过 25ms。



### 内存淘汰策略

Redis 提供了配置参数 「 maxmemory 」来限制内存大小。当前已用内存超过 maxmemory 限定时，触发淘汰策略。

- **no-eviction**：不会淘汰过期键。不会继续写操作 (del 请求可以继续服务)。采用这种策略可以保证数据不被丢失，但会让线上业务无法持续进行。这是默认的淘汰策略。
- **volatile-lru**：对设置了过期时间的键，优先淘汰最少使用的键。
- **volatile-ttl**：优先淘汰即将要过期的键。
- **volatile-random**：随机淘汰过期键集合中的键。
- **allkeys-lru**：区别于 volatile-lru，这个策略要淘汰的对象是所有键，意味着没有设置过期时间的键也会被淘汰。
- **allkeys-random**：跟上面几乎一样，不过淘汰的键是随机的键。



以上，volatile-xxx 策略只会针对设置过期时间的键进行淘汰，allkeys-xxx 策略会对所有的键进行淘汰。

- 如果 Redis 只是用来做缓存，应该使用 allkeys-xxx 策略，客户端写缓存时不必设置过期时间。
- 如果还想同时使用 Redis 的持久化功能，应该使用 volatile-xxx 策略，可以保留没有设置过期时间的键，永远不会被淘汰。



#### LRU 算法

Least Recently Used ，最近最少使用。如果最近访问较少，那么将来访问次数也少。

「 双向链表 + 字典 」实现 LRU 算法。

Reids 使用的是一种近似 LRU 算法，跟 LRU 算法有所不同。



相关文章：

- [LRU原理和Redis实现——一个今日头条的面试题](https://zhuanlan.zhihu.com/p/34133067)

- [【Redis源码分析】Redis中的LRU算法实现](https://segmentfault.com/a/1190000017555834)