## cont(*) 为什么慢

### 目录

- [cont(*) 的实现](#cont(*)-的实现)
- [MySQL 对 cont(*) 做了什么优化？](#MySQL-对-cont(*)-做了什么优化)
- [如何提高计数效率？](#如何提高计数效率)
- [count(*)，count(id)，count(1)，count(字段) 的效率和区别](#count(*)，count(id)，count(1)，count(字段)-的效率和区别)



### cont(*) 的实现

- 在 MyISAM 引擎中，把一个表的总行数存储在磁盘上，在没有过滤条件下，count(*) 会直接返回这个数，因此效率高
- 在 InnoDB 中，执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数，因此效率较低。



### MySQL 对 cont(*) 做了什么优化？

InnoDB 是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以，普通索引树比主键索引树小很多。对于 count(*) 这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，**MySQL 优化器会找到最小的那棵树来遍历**。



### 如何提高计数效率

- **用缓存保存计数**

  每插入一条数据，给缓存的数值 +1。

  存在数据不一致和计数不正确的问题。

  把计数放在 Redis 里面，不能够保证计数和 MySQL 表里的数据精确一致的原因是，这两个不同的存储构成的系统，不支持分布式事务，无法拿到精确一致的视图。

- **在数据库中保存计数**

  把计数存到数据库单独一张表中。

  利用事务的特性，原子性和隔离性。插入数据后，更新计数值，两个操作在一个事务中进行中，在可重复读的事务级别下可以保证数据的一致性和计数结果正确。





### count(*)，cont(id)，cont(1)，cont(字段) 的效率和区别

count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加。最后返回累计值。

count(*)、count(主键 id) 和 count(1) 都表示返回满足条件的结果集的总行数；

而 count(字段），则表示返回满足条件的数据行里面，参数字段不为 NULL 的总个数。

- count(id)：InnoDB 引擎遍历整张表，把每行的 id 都取出来，返回给 Server 层。Server 层拿到 id后，判断是不可能为空，按行累加。

- count(1)：InnoDB 引擎遍历整张表，不取值。Server 层对于返回的每一行，放一个数字 1 进去，判断是不可能为空的，按行累加。

  可以对比出来，count(1) 执行得要比 count(id) 快。因为从引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作。

- count(字段)：

  - 如果这个字段是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；
  - 如果这个字段定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。

count(*) 不会把全部字段取出来，而去专门做了优化，不取值，而直接统计所有的行数。

count(*) 肯定不是 null，按行累加。



**所以结论是：按照效率排序的话，count(字段) < count(主键 id) < count(1) ≈ count(*)，**

**所以，尽量使用 count(*)。**
