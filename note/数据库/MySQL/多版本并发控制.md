## 多版本并发控制

多版本并发控制（MVCC）典型的有「 乐观并发控制 」和「 悲观并发控制 」，体现的就是乐观锁和悲观锁机制。

MVCC 只在 REPEATABLE READ 和 READ COMMITED 两个隔离级别下工作。



### 乐观锁

乐观锁机制下每次操作数据的时候总是认为别人不会操作数据，只有要在操作数据的时候判断下数据是否更原来一致，如果数据不一致说明有其他线程操作了数据，如果一致则没有其他线程操作过数据，则当前操作成功。

**适用场景**

乐观锁比较适合并发量不高，并且读多写少的场景。如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行 retry，这样反倒是降低了性能。



在数据库中实现乐观锁的方式：

- 表中加版本号（version）字段，每次更新一行记录，都对版本号加 1。开始更新之前先查询 version，更新的时候带上查出来的 version 和当前数据库里的做比较，如果相等，则说明没有其他操作修改过这行数据，如果不相等则说明 version 值被修改检测到了并发冲突，本次执行失败，在应用代码中可获知失败进行 retry。

  ```sql
  update table set num = 1,version = version+1 where id= #{id} and version = #{oldVersion}
  ```

- 借助行更新时间戳，检测方法则与上述方法相识，通过检测当前更新时间是否与更新开始时获取的更新时间时间戳相等。

- 对字段本身做判断，例如一个较常见的场景：库存的扣减，只要扣减后的值大于等于零即可。

  ```sql
  update table set num = num – #{deduct} where id = #{id} and num >= #{deduct}
  ```



**优点：**

由于在检测数据冲突时并不依赖数据库本身的锁机制，不会影响请求的性能，当产生并发且并发量较小的时候只有少部分请求会失败。

**缺点：**

1. 一需要对表的设计增加额外的字段，增加了数据库的冗余。
2. 当应用并发量高的时候，version 值在频繁变化，则会导致大量请求失败，影响系统的可用性。
3. 我们通过上述 SQL 语句还可以看到，数据库锁都是作用于同一行数据记录上，这就导致一个明显的缺点，在一些特殊场景，如大促、秒杀等活动开展的时候，大量的请求同时请求同一条记录的行锁，会对数据库产生很大的写压力。



### 悲观锁

总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**）。MySQL 中很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。



**适用场景**

如果是多写的情况，一般会经常产生冲突，适用悲观锁。

并发量较小又需要独占读取结果并依赖读取的结果进行判断。



在数据库中的实现：

通过数据库锁机制实现，即对查询语句添加 for update 关键字，锁定行，当这些行被锁定后，其他的线程可以读取这些行，但不能更改或删除这些行，直到该语句提交事务或回滚。

```sql
select * from table where id = 1 for update;
update table set num = num - 1 where id = 1;
```

当一个请求 A 开启事务并执行此 sql 同时未提交事务时，另一个线程 B 发起请求，此时 B 将阻塞在加了锁的查询语句上，直到 A 请求的事务提交或者回滚，B 才会继续执行，保证了访问的隔离性。



**优点：**
每一次行数据的访问都是独占的，只有当正在访问该行数据的请求事务提交以后，其他请求才能依次访问该数据，否则将阻塞等待锁的获取。悲观锁可以严格保证数据访问的安全。



**缺点：**
每次请求都会额外产生加锁的开销且未获取到锁的请求将会阻塞等待锁的获取，在高并发环境下，**容易造成大量请求阻塞，影响系统可用性**。另外，悲观锁使用不当还可能产生**死锁**的情况。



[浅谈实现数据库乐观锁和悲观锁](https://blog.csdn.net/qidasheng2012/article/details/83007103)