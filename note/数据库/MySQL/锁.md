## 锁

### 目录

-  [全局锁](#全局锁)
- [表级锁](#表级锁)
- [如何安全地给小表加字段？](#如何安全地给小表加字段)
- [行级锁](#行级锁)
- [死锁的处理策略](#死锁的处理策略)
- [如何解决由热点行更新导致的性能问题？](#如何解决由热点行更新导致的性能问题)



读写锁：

- 读锁，也叫共享锁
- 写锁，也叫排他锁



按锁粒度划分：
- 全局锁
- 表级锁
  - 表锁
  - 元数据锁 ( metadata lock ,MDL)
- 行级锁



乐观锁

悲观锁

多版本并发控制


### 全局锁
对整个数据库实例加锁。

MySQL 提供了一个加全局读锁的方法，命令是 「 Flush tables with read lock (FTWRL) 」。

当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。

**全局锁的典型使用场景是，做全库逻辑备份**。

另一个方法是在可重复读隔离级别下开启一个事务。

MySQL 自带有逻辑备份工具「 mysqldump 」，使用参数「 single-transaction 」导数据之前就会启动一个事务。

single-transaction 方法只适用于所有的表使用事务引擎的库。



### 表级锁

有表锁，元数据锁 ( metadata lock ,MDL)

表锁的语法是 「 lock tables … read/write 」。

在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于 InnoDB 这种支持行锁的引擎，一般不使用 lock tables 命令来控制并发，毕竟锁住整个表的影响面还是太大。



MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性。

**在对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。**

事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。



### 如何安全地给小表加字段？

**解决长事务，事务不提交就一直占着 MDL 锁**。可以在 MySQL 的 information_schema 库的 innodb_trx 表中查到当前执行中的事务。如果要做 DDL 变更的表刚好有长事务在执行，要考虑**先暂停 DDL，或者 kill 掉这个长事务**。



**如果要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你又不得不加个字段，你该怎么做呢？**

这时候 kill 可能未必管用，因为新的请求马上就来了。

比较理想的机制是，**在 alter table 语句里面设定等待时间**，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过程。





[MySQL 实战 45 讲 - 全局锁和表锁 ：给表加个字段怎么有这么多阻碍？](https://time.geekbang.org/column/article/69862)



表锁一般是在数据库引擎不支持行锁的时候才会被用到的。InnoDB 支持行锁。

### 行级锁

**什么时候加锁？**

在 InnoDB 事务中，行锁只有在行被访问的时候才会加上，即逐行加锁。

**什么时候释放锁？**

行锁要到事务提交了才释放。



**这个就是两阶段锁协议：加锁阶段和解锁阶段。**



**所以，如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。减少事务之间的锁等待，提升并发度。**



select 语句如下这种是快照读，不加锁。

```sql
select * from table where num = ?
```



### 死锁的处理策略

当出现死锁后，有两种策略可以解锁：

- **一种策略是设置超时时间**。直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。

  **问题：**

  超时时间设置过长，其他线程等待的时间太长影响线上并发性能；超时时间设置过短，如果只是单纯的锁等待就会被解开。

- **另一种是主动死锁检测**。发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。

  **问题：**

  每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n) 的操作。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的 CPU 资源。因此，就会看到 CPU 利用率很高，但是每秒却执行不了几个事务。



### 如何解决由热点行更新导致的性能问题？

问题的根源在于，死锁检测要耗费大量的 CPU 资源。

- **确保业务上不会出现死锁，关闭死锁检测**。

  **问题：**

  这种操作本身带有一定的风险，因为业务设计的时候一般不会把死锁当做一个严重错误，毕竟出现死锁了，就回滚，然后通过业务重试一般就没问题了，这是业务无损的。而关掉死锁检测意味着可能会出现大量的超时，这是业务有损的。

- **控制并发度**。对应相同行的更新，在进入引擎之前排队。这样在 InnoDB 内部就不会有大量的死锁检测工作了。在数据库服务端上做。借助中间件实现，或修改 MySQL 源码。



### 什么时候行锁升级为表锁

innodb 行级锁是通过「 锁索引记录 」实现的，如果更新的列没建索引或索引失效是会锁住整个表的。



[MySQL 实战 45 讲 - 行锁功过：怎么减少行锁对性能的影响？](https://time.geekbang.org/column/article/70215)



