## 锁

读写锁：

- 读锁，也叫共享锁
- 写锁，也叫排他锁



按锁粒度划分：
- 全局锁
- 表级锁
  - 表锁
  - 元数据锁 ( metadata lock ,MDL)
- 行级锁




### 全局锁
对整个数据库实例加锁。

MySQL 提供了一个加全局读锁的方法，命令是 「 Flush tables with read lock (FTWRL) 」。

当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。

**全局锁的典型使用场景是，做全库逻辑备份**。

另一个方法是在可重复读隔离级别下开启一个事务。

MySQL 自带有逻辑备份工具「 mysqldump 」，使用参数「 single-transaction 」导数据之前就会启动一个事务。

single-transaction 方法只适用于所有的表使用事务引擎的库。



### 表级锁

有表锁，元数据锁 ( metadata lock ,MDL)

表锁的语法是 「 lock tables … read/write 」。

在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于 InnoDB 这种支持行锁的引擎，一般不使用 lock tables 命令来控制并发，毕竟锁住整个表的影响面还是太大。



MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性。

在对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。

事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。



### 如何安全地给小表加字段？

- 解决长事务，事务不提交就一直占着 MDL 锁。
- 在 alter table 语句里加等待时间，如果在等待时间里拿不到 MDL 锁也不会阻塞后面的业务，之后再通过重试命令来重试这个过程。





[MySQL 实战 45 讲-全局锁和表锁 ：给表加个字段怎么有这么多阻碍？](https://time.geekbang.org/column/article/69862)
