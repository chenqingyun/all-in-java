## MySQL 性能优化

三个方面：

- 库表结构优化
- 索引优化
- SQL 优化



### 库表结构优化

- 尽量使用可以正确存储数据的最小数据类型。最小的数据类型通常更快，因为占用更少的磁盘、内存和 CPU 	缓存，并且处理时需要的 CPU 周期更少。
- 使用简单数据类型。

- 非负型的数据使用无符号的整型来存储。无符号相对于有符号可以多出一倍的存储空间。
- 避免使用 TEXT、BLOB 大数据类型。
- 避免使用 ENUM 数据类型。
- 尽量避免 「 NULL 」。最好指定列为 「 NOT NULL 」，并设置一个默认值。索引 NULL 列需要额外的空间的来保存，占用更多空间；进行比较和计算时需要对 NULL 值做特别处理。
- 使用 TIMESTAMP 或 DATETIME 类型存储时间。
- 金额相关数据使用 DECIMAL 类型
- [MySQL数据类型选择](https://www.awaimai.com/1146.html)



为列选择数据类型时：

1. 先确定大类型：数字、字符串、时间等。
2. 然后选择具体数据类型。相同类型的数据，存储的长度和范围不一样，允许的精确度不一样等。



参考：

《高性能 MySQL 第三版》第四章 Schema 与数据类型优化



### 索引优化

- 最左前缀原则。
- 建立索引的列，不允许为 null。
- 尽量选择区分度高的列作为索引
- 。。。。。



### SQL 优化

- 避免隐式转换，会导致索引失效，影响性能。

- like 查询，左边尽量不要有「 % 」，不会走索引。

- 禁止使用「 select * 」。

- 避免查询不必要的数据，加 limit。

- 使用缓存，避免重复查询相同的数据。

- 有时候一个复杂的查询拆分成几个小查询会更好。

  > 一个大的语句可能需要一次性锁住很多数据，占满整个事务日志，耗尽系统资源，阻塞其他语句。小语句可以将压力分散到较长的时间段里，降低对服务器的影响，还可以减少删除时锁的等待时间。

- 分解关联查询。

- 最好使用 「 count(*) 」。

- 除非需要消除重复行，不然尽量使用「 UNION ALL 」。如果没有加「 ALL 」关键字，MySQL 会给临时表加 「 DISTINCT 」关键字，会导致对整个临时表做唯一性检查。

- 使用不等于操作符如：<>、!= 等不走索引；

- 。。。。



