## 垃圾收集算法

### 标记-清除（Mark-Sweep）算法

最基础的垃圾收集算法

**算法思路**：分标记，清除两个阶段，先标记出所有活动的对象，标记完成后统一回收未标记的对象。

**算法实现**：[GC 标记 - 清除算法](<http://www.ituring.com.cn/book/tupubarticle/10955>)

**优点：**

- 算法简单，实现容易

**不足：**

- 效率问题。标记和清除的效率都不高（递归和全堆对象遍历）；

- 空间问题。标记清除后会产生大量不连续的内存空间碎片，当需要分配较大对象时，无法找到足够大的连续内存空间而不得不触发一次垃圾收集动作。

  

### 复制（Coping）算法

新生代的回收一般采用这种算法

**算法思路**：将可用内存划分为两块内存，每次只使用其中一块，当这块内存用完了，将存活对象移到另一块内存上，再清理该内存上的垃圾对象。

**优点：**

- 实现简单，高效，只需要遍历一遍内存空间。

- 避免产生大量不连续的内存空间碎片。


**不足：**

- 可用内存缩小。
- 如果对象存活率高，复制对象的开销较大。

在新生代中采用该算法， 新生代划分为 Eden 区和 Form Survivor 区和 To Survivor，默认比例 8:1:1。每次使用Eden 区和 From Survivor 区，垃圾回收时，存活对象复制到 To Survivor 区中，当 To Survivor 中空间不足时，复制到老年代。

具体回收过程参考：[新生代垃圾回收](<http://wiki.jikexueyuan.com/project/jvm-parameter/garbage-collection.html>)



### 标记-整理（Mark-Compact）算法

老年代一般采用这种算法

**算法思路**：分标记和整理两个阶段，标记阶段的实现同标记-清理算法标记阶段一样，遍历GC Roots，然后将存活的对象标记。整理阶段是将所有存活对象移动至一端，按照内存地址依次排列，然后直接清理掉边界以外的内存。

**优点**：

- 不会产生内存空间碎片
- 不用缩小可用内存

**不足**：

- 效率不高，标记完存活对象后还要对其进行整理。

效率：复制算法 > 标记-整理算法 > 标记-清除算法



### 分代收集算法

将 Java 堆分为新生代和老年代

新生代：每次垃圾收集时都有大批的对象死去，只有少量对象存活，适合用复制算法。

老年代：对象存活率较高，且没有额外的空间进行分配担保，使用标记-清除算法或标记-整理算法。

