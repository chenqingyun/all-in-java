## 垃圾收集器

<div align="center"><img src="https://upload-images.jianshu.io/upload_images/3297676-8efc4ffc72cf0267.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width= "700px"></div>

### Serial 收集器

**单线程**，Client 模式下默认的**新生代收集器**。



**优点**：

- 简单高效（与其他单线程收集器比）

**缺点**：

- Stop The World ，目前几乎所有收集器工作时都需要暂停用户线程。



### ParNew 收集器

Serial 收集器的**多线程**版本，运行在 Server 模式下首选的**新生代收集器**。

除 Serial 收集器外，只有他能与 CMS 收集器配合工作。

单 CPU 环境中，该收集器效率不比 Serial 收集器效率高，由于存在线程切换的开销，即使多个 CPU 也不一定。



### Parallel Scavenge 收集器

**新生代收集器**，使用**复制算法**，并行的**多线程**收集器。

目标是达到一个可控制的吞吐量，”吞吐量优先“的收集器。

GC 自适应调节策略。



### Serial Old 收集器

Serial 收集器的**老年代**版本，**单线程**，使用**标记-整理算法**。

主要意义是给 Client 模式下的虚拟机使用。

在 Server 模式下，主要用途：

- 在 JDK 1.5 及以前的版本与 Parallel Scavenge 收集器一起使用。
- 作为 CMS 收集器的后备预案，当发生 Cocurrent Mode Failure 时使用。



### Parallel Old 收集器

Parallel Scavenge 收集器的**老年代**版本，**多线程**，使用**标记-整理算法**。

在注重吞吐量以及 CPU 资源敏感的场合可以优先考虑 Parallel Scavenge 收集器 加 Parallel Old 收集器。



### CMS 收集器

CMS （Cocurrent Mark Sweep）收集器，目标是缩短垃圾回收时用户线程暂停的时间。

**老年代收集器**，使用**标记-清除算法**。

**运作过程**：

- 初始标记
- 并发标记
- 重新标记
- 并发清除

初始标记：仅标记一下 GC Roots 能直接关联到的对象，速度快。

并发标记：进行 GC Roots Tracing 的过程：从 GC Roots 开始对对象进行可达性分析，找出存活的对象，这阶段耗时较长。

重新标记：修正在并发标记期间因用户线程继续运行而导致标记产生变动的那一部分对象的标记记录。停顿时间比初始标记阶段长，比并发标记时间短。

并发清除：清除垃圾对象的过程，用户线程继续运作。

**初始标记和重新标记需要STW**（Stop The World）。



**优点：**

- 并发收集，低停顿

**不足**：

- 对 CPU 资源敏感，并发阶段会占用一部分 CPU 资源，导致应用程序变慢，总吞吐量降低；
- 无法处理浮动垃圾，导致 Concurrent Mode Failure 从而导致另一次 Full GC；
- 产生大量空间碎片。



### G1 收集器

面向服务端应用的垃圾收集器。

**特点：**

- 并行与并发：缩短 STW 时间
- 分代收集
- 空间整合：G1 收集器基于标记-整理算法实现
- 可预测的停顿



Region 划分内存空间以及有优先级的区域回收方式，保证 G1收集器提高回收效率。



**运作流程：**

- 初始标记
- 并发标记
- 最终标记
- 筛选回收