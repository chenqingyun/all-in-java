# Java  虚拟机运行时数据区



Java 虚拟机定义了几种程序运行期间会使用到的运行时数据区（Runtime Data Areas），有些随着虚拟机启动而创建，随着虚拟机退出而销毁，这些区域是线程共享的；有些则与线程一一对应，随着线程的启动和结束而建立和销毁，这些区域是线程私有的。根据 Oracle 官方的 *The Java Virtual Machine Specification, Java SE 8 Edition* 中的规定，Java 虚拟机所管理的内存包括以下几个运行时数据区，如图所示：

<div align="center"><img src="https://upload-images.jianshu.io/upload_images/3297676-a984b0bd6be1c835.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width= "500px"></div>

在 Java 虚拟机中，程序计数寄存器、Java 虚拟机栈、本地方法栈这些区域是线程私有的，堆、方法区是线程共享的。

## 程序计数器

程序计数器（Program Counter Register）是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。

**有什么作用？**

在虚拟机的概念模型里，字节码解释器工作时就是通过改变程序计数器的值来选取下一条需要执行的字节码指令。分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器来实现。

**是线程私有的区域**

在 Java 虚拟机中，多线程是通过线程轮流切换并分配 CPU 时间片的方式来实现的。为了线程在切换后能恢复到正确的执行位置，每条线程就需要有一个独立的程序计数器，来记录上次执行到哪了。计数器在线程启动时创建，是线程私有的内存。

**存储对象？**

当线程正在执行的是一个 Java 方法，计数器**存储的是正在执行的虚拟机字节码指令的地址**；如果正在执行的是 Native 方法，这个计数器值为空（ Undefined）。

**为什么执行 Native 方法时，计数器值为空（ Undefined ）**？

> 因为 Native 方法是非 Java 语言实现的，该方法是在其原生平台上执行的，就不需要在 Java 平台上将其编译成字节码指令，而程序计数器记录的是字节码指令的地址，所以计数器在这里就不需要，当然就为空了。



**此区域内存是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。**

>计数器存储的是字节码指令的地址，只是值在发生变化不会扩展内存，因此不会出现 OOM 的情况。



## Java 虚拟机栈

Java 虚拟机栈（Java Virtual Machine Stack）描述的是 Java 方法执行的内存模型。

每个方法在执行的同时都会创建一个**栈帧（Stack Frame）**用于存储**局部变量表、操作数栈、动态链接、方法出口等信息**。方法被调用，对应着一个栈帧在虚拟机栈中的入栈，方法执行结束，对应栈帧的出栈。

> 栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，是虚拟机运行时数据区中的虚拟机栈的栈元素。关于栈帧的详细说明可以阅读《深入理解 Java 虚拟机 第2版》一书 P236 。



**通常人们说的栈内存一般指 Java 虚拟机栈，或是 Java 虚拟机栈中局部变量表部分。**

**局部变量表是什么**？

局部变量表是一组变量存储空间，**存储方法的参数和方法内的局部变量**（编译期可知的各种基本数据类型、对象引用和 returnAddress 类型）。

局部变量表的内存空间在编译期间完成分配，在方法运行期间不会改变大小。



**异常情况？**

在 Java 虚拟机规范中，对这个区域规定了两种异常情况：

- **StackOverflowError**：栈溢出。如果线程请求的栈深度大于虚拟机所允许的最大栈深度，将会抛出该异常。
- **OutOfMemoryError**：内存溢出。如果线程在申请内存时，虚拟机分配给线程的内存大小无法再分配足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈时，就会抛出此异常。



**如何设定容量大小？**

可通过参数 ``-Xss``设置虚拟机栈的大小，如参数`` -Xss128k`` 表示设置虚拟机栈大小为 128k。

[StackOverflowError 详解]()

[OutOfMemoryError 详解]()



## 本地方法栈

本地方法栈（Native Method Stack）跟 Java 虚拟机栈相识，区别就是 Java 虚拟机栈是为 Java 方法服务的，本地方法栈是为 Native 方法服务的。

在有的虚拟机中，如 Sun HotSpot 虚拟机将本地方法栈和 Java 虚拟机栈合二为一。

与 Java 虚拟机栈一样，本地方法栈也会抛出 StackOverflowError 和 OutOfMemoryError 异常。

可通过参数 ``-Xoss``设置本地方法栈的大小，由于在 HotSpot 虚拟机中不区分虚拟机栈和本地方法栈，因此该参数实际上是无效的，栈容量只由 ``-Xss`` 参数设定。



## Java 堆

Java 堆（Java Heap）是 Java 虚拟机所管理的内存区域中最大的一块。Java 堆随 Java 虚拟机的启动而创建，被所有线程共享。

**几乎所有的对象实例和数组对象在此区域中分配内存**。

Java 堆是垃圾收集器主要管理区域，因此 Java 堆也被称为 **GC堆**（Garbage Collected Heap）。

- 从内存回收的角度看，由于垃圾收集器基本上都采用分代收集算法，所以 Java 堆可以分为：新生代（Young）和老年代（Old），新生代可以细分为 Eden 空间、From Survivor 空间、To Survivor 空间等；
- 从内存分配的角度看，Java 堆可能划分为多个线程私有的分配缓存区。

根据 Java 虚拟机规范的规定，Java 堆的容量可以是固定大小的，也可以随着程序执行的过程动态扩展，并且在不需要过多空间时自动收缩。

**如何设定堆内存大小？**

通过参数 ``-Xms`` 初始化堆内存大小，``-Xmx`` 设定最大堆内存，如 ``-Xms20M``表示堆内存的最小值为 20M，``-Xmx20M`` 表示堆内存最大为 20M。将 ``-Xmx`` 和 ``-Xms`` 设置为一样可避免 JVM 堆内存自动扩展。

**异常情况：**

如果实际所需要的堆超过自动内存管理系统能提供的最大容量，Java 虚拟机会抛出 OutOfMemoryError 异常。



## 方法区

方法区（Method Area）是堆的逻辑组成部分，在虚拟机启动时创建，也是线程共享的内存区域。

方法区存储**已被虚拟机加载的类的信息，常量、静态变量，即时编译编译后的代码等数据**。

与堆一样，不需要连续的内存空间和可以选择固定大小或可动态扩展外，虚拟机可以选择在方法区不实现垃圾收集和压缩。该区域的内存回收目标主要针对常量池的回收和对类型的卸载。

当方法区无法满足内存分配需求时，会抛出 OutOfMemoryError 异常。

HotSpot 虚拟机从 JDK 8 开始取消了永久代（Permanent Generation）（永久代是 HotSpot 虚拟机对方法区的实现），引入了元空间（MetaSpace）。元空间并不在虚拟机中，而是使用本地内存。

JDK 8 之后，通过参数``-XX:MetaspaceSize`` 和 ``-XX:MaxMetaspaceSize`` 设定元空间最小值和最大值，如 ``-XX:MetaspaceSize=20M``表示初始元空间大小为 20M，``-XX:MaxMetaspaceSize=20M``表示元空间最大容量为20M。



## 运行时常量池

运行时常量池（Runtime Constant Pool）是方法区的一部分，在虚拟机加载类或接口时创建。

运行时常量池是 class 文件中每一个类或接口的常量池表（Constant Pool Table）的运行时表现形式。

class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于**存储编译期生成的各种字面量和符合引用**，这部分内容将在类加载后进入方法区的运行时常量池中存放。

TODO

[class 文件格式]()

[常量池和运行时常量池]()



在创建类或接口时，如果构造运行时常量池所需的内存空间时超过了方法区所能提供的最大值时，就抛出 OutOfMemoryError 异常。

> 关于构造运行时常量池的详细信息，参考[类加载机制]()



## 总结

- Java 虚拟机运行时数据区划分为程序计数器、Java 虚拟机栈、本地方法栈、Java 堆、方法区和运行时常量池。

- 程序计数器存储字节码指令的地址；Java 虚拟机栈存储基本数据类型、对象引用和 returnAddress 类型；本地方法栈同 Java 虚拟机栈；Java 堆存储对象实例和数组对象的；方法区存储加载的类的信息、常量、静态变量、编译后的代码等数据；运行时常量池是方法区的一部分，存储编译期生成的各种字面量和符号引用。

- 程序计数器、Java 虚拟机栈和本地方法栈是线程私有的内存区域；Java 堆、方法区和运行时常量池是线程共享的内存区域，随 Java 虚拟机的启动而创建，停止而销毁。

- 除了程序计数器不会发生 OutOfMemoryError ，其他内存区域都会发生此异常。




![image.png](https://upload-images.jianshu.io/upload_images/3297676-1625d9efc07e62a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 参考

- *The Java Virtual Machine Specification, Java SE 8 Edition* . Oracle
- 《深入理解 Java 虚拟机 第2版》周志明

