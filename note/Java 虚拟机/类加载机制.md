## 虚拟机类加载机制

## 目录

- [类加载时机](#类加载时机)
- [类加载过程](#类加载过程)
- [类加载器](#类加载器)
  - [双亲委派模型](#双亲委派模型)

### 类加载时机

Java虚拟机规范并没有规定什么时候需要进行类的加载阶段，但是**对一个类进行主动引用时会触发类的初始化**。

**具体有 5 种场景：**

1. 使用 new 关键字实例化对象、读取或设置类的静态字段 (被 final 修饰，已在编译期把结果放入常量池的静态字段除外)、以及调用一个类的静态方法的时候。
2. 使用 java.lang.reflect 包的方法对类进行反射调用的时候。
3. 当初始化一个类时，发现其父类还未初始化，则先初始化其父类。
4. 当虚拟机启动时，会先初始化定义了 main() 方法的类。
5. 当使用jdk1.7动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果REF_getstatic,REF_putstatic,REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。



接口的初始化过程与类有点不同，接口并不要求其父接口全部都完成初始化，只有在使用到父接口的时候(如引用接口中定义的常量) 才会初始化。



**被动引用不会触发初始化：**

1. 通过子类引用父类的静态字段，不会导致子类初始化。
2. 通过数组定义来引用类。
3. 访问类的常量，不会初始化类。常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的的类的初始化。



相关文章：

[JVM类生命周期概述：加载时机与加载过程](https://blog.csdn.net/justloveyou_/article/details/72466105)


### 类加载过程

- 加载 
- 连接
  - 验证 
  - 准备 
  - 解析 
- 初始化

  

相关文章：

[两道面试题，带你解析Java类加载机制](https://www.cnblogs.com/chanshuyi/p/the_java_class_load_mechamism.html)





### 类加载器

3 种类加载器

- 启动类加载器 (Bootstrap ClassLoader)

- 扩展类加载器 (Extension ClassLoader)

- 应用程序类加载器 (Application ClassLoader)

  

### 双亲委派模型

Parents Delegation Model

**工作过程：**

当一个类加载器接收到类加载请求时，首先会把请求委托给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该到达顶层的启动类加载器。当父类加载器无法完成这个加载请求时（无法找到这个类），子类加载器才会尝试自己去加载。



相关文章：

[深入分析Java类加载器原理](https://juejin.im/post/5c866e00f265da2dd1689f8b#heading-8)