## 垃圾回收机制

### 目录
- [对象存活判断算法](#对象存活判断算法)
- [垃圾收集算法](#垃圾收集算法)
- [垃圾收集器](#垃圾收集器)
- [内存分配与回收策略](#内存分配与回收策略)
- [如何减少 GC 开销](#如何减少-gc-开销)
- [Major GC 和 Minor GC 频繁如何解决](#major-gc-和-minor-gc-频繁如何解决)
- [什么时候可能会触发 STW 的 Full GC](#什么时候可能会触发-stw-的-full-gc)



垃圾回收（Garbage Collection）机制是 Java 虚拟机垃圾回收器提供的一种用于在空闲时间不定时回收无任何对象引用的对象占据的内存空间的一种机制。



### 对象存活判断算法

如何判断一个对象是否存活？常见的判断是否存活有两种方法：引用计数法和可达性分析算法。



#### 引用计数法

为每一个创建的对象分配一个引用计数器，用来存储该对象被引用的个数。每当有一个地方引用它时，计数器值就加 1，当引用失效时，计数器值就减 1，当为 0 时表示该对象没有被任何对象引用。



存在的问题：

很难解决对象之间相互引用的问题。因此，在 Java 的垃圾回收器中没有使用这种算法。



#### 可达性分析算法
以 GC Roots 对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为「 引用链 」，当一个对象没有任何引用链到达 GC Roots，则证明此对象是不可用的。



可作为 GC Roots 的对象：

- 虚拟机栈（帧栈中的本地变量表）中引用的对象。
- 方法区中静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中 JNI 引用的对象。



### 垃圾收集算法



#### 标记-清除（Mark-Sweep）算法

最基础的垃圾收集算法

**算法思路**：分标记，清除两个阶段，先标记出所有活动的对象，标记完成后统一回收未标记的对象。

**算法实现**：[GC 标记 - 清除算法](<http://www.ituring.com.cn/book/tupubarticle/10955>)

**优点：**

- 算法简单，实现容易

**不足：**

- 效率问题。标记和清除的效率都不高（递归和全堆对象遍历）；

- 空间问题。标记清除后会产生大量不连续的内存空间碎片，当需要分配较大对象时，无法找到足够大的连续内存空间而不得不触发一次垃圾收集动作。

  

#### 复制（Coping）算法

**新生代的回收一般采用复制算法**

**算法思路**：将可用内存划分为两块内存，每次只使用其中一块，当这块内存用完了，将存活对象移到另一块内存上，再清理该内存上的垃圾对象。

**优点：**

- 实现简单，高效，只需要遍历一遍内存空间。

- 避免产生大量不连续的内存空间碎片。


**不足：**

- 可用内存缩小。
- 如果对象存活率高，复制对象的开销较大。



在新生代中采用该算法， 新生代划分为 Eden 区和 Form Survivor 区和 To Survivor，默认比例 8:1:1。每次使用Eden 区和 From Survivor 区，垃圾回收时，存活对象复制到 To Survivor 区中，当 To Survivor 中空间不足时，复制到老年代。



工作原理如下：

1. Eden 区最大，新创建的对象首先往 Eden 区分配。当 Eden 区快要满了，则会触发 **Minor GC**，把存活对象放入 From Survivor 区，清空 Eden 区中已死的对象；
2. Eden 区被清空后，继续对外提供堆内存；
3. 当 Eden 区再次被填满，又触发一次 Minor GC，把存活对象放入 To Survivor 区，清理掉 Eden 区和 From 区的死亡对象；
4. Eden 区继续对外提供堆内存，并重复上述过程，即在 Eden 区填满后，把 Eden 区和某个 Survivor 区的存活对象放到另一个 Survivor 区。From 区和 To 区是相对的关系，哪个区中有存活对象，哪个区就是 From 区。
5. 当 To 区被填满，且仍有对象未被复制完毕时，或者某些对象在到达一定年龄了（对象每熬过一次 Minor GC ，年龄加1，到一定年龄(默认 15 岁)，进入老年代），则把这部分剩余对象放到 Old 区；
6. 当  Old 区也被填满时，进行  Major GC，对 Old 区进行垃圾回收。
7. 那么会触发一次Full GC，Full GC 会对整个Heap进行一次GC，如果 Full GC 后还有无法给新创建的对象分配内存，或者无法移动那些需要进入老年代中的对象，那么 JVM 抛出 **OutOfMemoryError**

参考：[Java 垃圾回收机制](https://juejin.im/post/5caf2b5cf265da036c577751)






**各种 GC？？？**

- Minor GC：新生代 GC，即发生在新生代（包括Eden区和Survivor区）的垃圾回收操作。
- Major GC：出现 Major GC 通常会出现至少一次 Minor GC。
- Full GC：是对整个 Heap （包括新生代、老年代、元空间）进行的 GC 操作，Major GC 通常是跟 Full GC 是等价的，收集整个 GC 堆。

[Major GC和Full GC的区别是什么？触发条件呢？](https://www.zhihu.com/question/41922036)





#### 标记-整理（Mark-Compact）算法

**老年代一般采用标记-整理算法**

**算法思路**：分标记和整理两个阶段，标记阶段的实现同标记-清理算法标记阶段一样，遍历GC Roots，然后将存活的对象标记。整理阶段是将所有存活对象移动至一端，按照内存地址依次排列，然后直接清理掉边界以外的内存。

**优点**：

- 不会产生内存空间碎片
- 不用缩小可用内存

**不足**：

- 效率不高，标记完存活对象后还要对其进行整理。

效率：复制算法 > 标记-整理算法 > 标记-清除算法



#### 分代收集算法

将 Java 堆分为新生代和老年代

- **新生代**：刚刚创建的对象。在代码运行时会持续不断地创造新的对象，这些新创建的对象会被统一放在一起。因为有很多局部变量等在新创建后很快会变成不可达的对象，快速死去，因此这块区域的特点是 **存活对象少，垃圾多**。
- **老年代**：存活了一段时间的对象。这些对象早早就被创建了，而且一直活了下来。我们把这些存活时间较长的对象放在一起，它们的特点是 **存活对象多，垃圾少** 。



因此：

**新生代：每次垃圾收集时都有大批的对象死去，只有少量对象存活，适合用复制算法。**

**老年代：对象存活率较高，且没有额外的空间进行分配担保，使用标记-清除算法或标记-整理算法。**





### 垃圾收集器

<div align="center"><img src="https://upload-images.jianshu.io/upload_images/3297676-8efc4ffc72cf0267.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width= "500px"></div>
#### 新生代收集器

##### Serial 收集器

**单线程**，Client 模式下默认的**新生代收集器**。



**优点**：

- 简单高效（与其他单线程收集器比）

**缺点**：

- Stop The World ，目前几乎所有收集器工作时都需要暂停用户线程。



##### ParNew 收集器

Serial 收集器的**多线程**版本，运行在 Server 模式下首选的**新生代收集器**。

除 Serial 收集器外，只有他能与 CMS 收集器配合工作。

单 CPU 环境中，该收集器效率不比 Serial 收集器效率高，由于存在线程切换的开销，即使多个 CPU 也不一定。



##### Parallel Scavenge 收集器

**新生代收集器**，使用**复制算法**，并行的**多线程**收集器。

目标是达到一个可控制的吞吐量，「 吞吐量优先 」的收集器。

GC 自适应调节策略。




#### 老年代收集器
##### Serial Old 收集器

Serial 收集器的**老年代**版本，**单线程**，使用**标记-整理算法**。

主要意义是给 Client 模式下的虚拟机使用。

在 Server 模式下，主要用途：

- 在 JDK 1.5 及以前的版本与 Parallel Scavenge 收集器一起使用。
- 作为 CMS 收集器的后备预案，当发生 Cocurrent Mode Failure 时使用。



##### Parallel Old 收集器

Parallel Scavenge 收集器的**老年代**版本，**多线程**，使用**标记-整理算法**。

在注重吞吐量以及 CPU 资源敏感的场合可以优先考虑 Parallel Scavenge 收集器 加 Parallel Old 收集器。



##### CMS 收集器

CMS （Cocurrent Mark Sweep）收集器，目标是缩短垃圾回收时用户线程暂停的时间。

**老年代收集器**，使用**标记-清除算法**。

**运作过程**：

- 初始标记
- 并发标记
- 重新标记
- 并发清除

初始标记：仅标记一下 GC Roots 能直接关联到的对象，速度快。

并发标记：进行 GC Roots Tracing 的过程：从 GC Roots 开始对对象进行可达性分析，找出存活的对象，这阶段耗时较长。

重新标记：修正在并发标记期间因用户线程继续运行而导致标记产生变动的那一部分对象的标记记录。停顿时间比初始标记阶段长，比并发标记时间短。

并发清除：清除垃圾对象的过程，用户线程继续运作。

**初始标记和重新标记需要 STW**（Stop The World）。



由于 CMS 收集器不是独占式的回收器，在 CMS 回收过程中，应用程序仍然在不停地工作。在应用程序工作过程中，又会不断地产生垃圾。这些新生成的垃圾在当前 CMS 回收过程中是无法清除的。同时，因为应用程序没有中断，所以在 CMS 回收过程中，还应该确保应用程序有足够的内存可用。因此，**CMS 收集器不会等待堆内存饱和时才进行垃圾回收，而是当前堆内存使用率达到某一阈值时，便开始进行回收**，以确保应用程序在 CMS 工作过程中依然有足够的空间支持应用程序运行。



**优点：**

- 并发收集，低停顿

**不足**：

- 对 CPU 资源敏感，并发阶段会占用一部分 CPU 资源，导致应用程序变慢，总吞吐量降低；
- 无法处理浮动垃圾，导致 Concurrent Mode Failure 从而导致另一次 Full GC；
- 产生大量空间碎片。



#### G1 收集器

面向服务端应用的垃圾收集器。

**特点：**

- **并行与并发**：G1 能充分利用多 CPU、多核环境下的硬件优势，使用多个 CPU 来缩短 STW 时间。
- **分代收集**
- **空间整合**：G1 收集器基于标记-整理算法实现。把内存「 化整为零 」，将 Java 堆划分为多个大小相等的独立区域（Region），从局部（两个 Region 之间）来看是基于复制算法实现的。这意味着 G1 运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。
- **可预测的停顿**：有计划的避免进行全堆垃圾收集。G1 跟踪各个 Region 的垃圾堆积的价值大小，优先回收价值大的 Region。


**Region 划分内存空间以及有优先级的区域回收方式，保证 G1收集器提高回收效率。**



**运作流程：**

- 初始标记
- 并发标记
- 最终标记
- 筛选回收

初始标记，最终标记，筛选回收过程都需要停顿用户线程。



### 内存分配与回收策略

对象主要分配在新生代的 Eden 区上，少数情况下也可能直接分配在老年代中（大对象直接分配在老年代）。

- **对象优先在 Eden 区分配**

  - 大多数情况下对象优先分配在新生代 Eden 区。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。

  - 相关参数：打印内存回收日志：-XX:+PrintGCDetails。

- **大对象直接进入老年代**

  - 大对象指需要大量连续内存空间的 Java 对象。

  - 常见大对象：过长的字符串以及大数组。
  - 经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以提供足够的内存空间来存放大对象。
  - 相关参数：如设置 -XX:PretenureSizeThreshold = 3145728 指令大于 3M 的对象直接进入老年代。

- **长期存活的对象将进入老年代**

  - 对象年龄计数，对象每熬过一次 Minor GC ，年龄加1，到一定年龄(默认 15 岁)，进入老年代。
  - 相关参数：-XX:MaxTenuringThreshold = 1，对象在第二次 Minor GC 时进入老年代。

- **动态年龄判断**

  - 如果在 Survivor 空间中相同年龄的所有对象大小总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就直接进入老年代。

- **空间分配担保**

  - 空间分配担保失败，进行 Full GC。



### 如何减少 GC 开销

1. 不要显示的调用System.gc()
2. 尽量减少临时对象的使用
3. 对象不用的时候最好显示置为 null
4. 尽量使用 StringBuffer，不使用 String 累加字符串
5. 能使用基本数据类型就不要使用封装类
6. 尽量减少静态对象变量的使用



### Major GC 和 Minor GC 频繁如何解决

首先优化 Minor GC 频繁问题。通常情况下，由于新生代空间较小，Eden 区很快被填满，就会导致频繁 Minor GC，因此可以通过增大新生代空间来降低 Minor GC 的频率。例如在相同的内存分配率的前提下，新生代中的Eden 区增加一倍，Minor GC 的次数就会减少一半。

服务中存在大量短期临时对象，扩容新生代空间后，Minor GC 频率降低，对象在新生代得到充分回收，只有生命周期长的对象才进入老年代。这样老年代增速变慢，Major GC 频率自然也会降低。



### 什么时候可能会触发 STW 的 Full GC

1. CMS GC 时出现 promotion failed 和 concurrent mode failure（concurrent mode failure发生的原因一般是 CMS 正在进行，但是由于老年代空间不足，需要尽快回收老年代里面的不再被使用的对象，这时停止所有的线程，同时终止 CMS，直接进行 Serial Old GC）； 
2. 统计得到的 Young GC 晋升到老年代的平均大小大于老年代的剩余空间； 
3. 主动触发 Full GC（执行jmap -histo:live [pid]）来避免碎片问题



参数优化：

- 对于性能要求很高的服务，建议将 MaxPermSize 和 MinPermSize 设置成一致；

- Xms 和 Xmx 也设置为相同，这样可以减少内存自动扩容和收缩带来的性能损失



[从实际案例聊聊Java应用的GC优化](https://tech.meituan.com/2017/12/29/jvm-optimize.html)




###  参考
- 《深入理解 Java 虚拟机 第2版》周志明
