# 垃圾回收机制

## 目录
- [对象存活判断算法](#对象存活判断算法)
- [垃圾收集算法](#垃圾收集算法)
- [垃圾收集器](#垃圾收集器)
- [内存分配与回收策略](#内存分配与回收策略)

## 对象存活判断算法
### 引用计数法
很难解决对象之间相互引用的问题。
### 可达性分析算法
以 GC Roots 对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为「引用链」，当一个对象没有任何引用链到达 GC Roots,则证明此对象是不可用的。
## 垃圾收集算法

### 标记-清除（Mark-Sweep）算法

最基础的垃圾收集算法

**算法思路**：分标记，清除两个阶段，先标记出所有活动的对象，标记完成后统一回收未标记的对象。

**算法实现**：[GC 标记 - 清除算法](<http://www.ituring.com.cn/book/tupubarticle/10955>)

**优点：**

- 算法简单，实现容易

**不足：**

- 效率问题。标记和清除的效率都不高（递归和全堆对象遍历）；

- 空间问题。标记清除后会产生大量不连续的内存空间碎片，当需要分配较大对象时，无法找到足够大的连续内存空间而不得不触发一次垃圾收集动作。

  

### 复制（Coping）算法

新生代的回收一般采用这种算法

**算法思路**：将可用内存划分为两块内存，每次只使用其中一块，当这块内存用完了，将存活对象移到另一块内存上，再清理该内存上的垃圾对象。

**优点：**

- 实现简单，高效，只需要遍历一遍内存空间。

- 避免产生大量不连续的内存空间碎片。


**不足：**

- 可用内存缩小。
- 如果对象存活率高，复制对象的开销较大。

在新生代中采用该算法， 新生代划分为 Eden 区和 Form Survivor 区和 To Survivor，默认比例 8:1:1。每次使用Eden 区和 From Survivor 区，垃圾回收时，存活对象复制到 To Survivor 区中，当 To Survivor 中空间不足时，复制到老年代。

具体回收过程参考：[新生代垃圾回收](<http://wiki.jikexueyuan.com/project/jvm-parameter/garbage-collection.html>)



### 标记-整理（Mark-Compact）算法

老年代一般采用这种算法

**算法思路**：分标记和整理两个阶段，标记阶段的实现同标记-清理算法标记阶段一样，遍历GC Roots，然后将存活的对象标记。整理阶段是将所有存活对象移动至一端，按照内存地址依次排列，然后直接清理掉边界以外的内存。

**优点**：

- 不会产生内存空间碎片
- 不用缩小可用内存

**不足**：

- 效率不高，标记完存活对象后还要对其进行整理。

效率：复制算法 > 标记-整理算法 > 标记-清除算法



### 分代收集算法

将 Java 堆分为新生代和老年代

新生代：每次垃圾收集时都有大批的对象死去，只有少量对象存活，适合用复制算法。

老年代：对象存活率较高，且没有额外的空间进行分配担保，使用标记-清除算法或标记-整理算法。





## 垃圾收集器

<div align="center"><img src="https://upload-images.jianshu.io/upload_images/3297676-8efc4ffc72cf0267.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width= "500px"></div>

### 新生代收集器
#### Serial 收集器

**单线程**，Client 模式下默认的**新生代收集器**。



**优点**：

- 简单高效（与其他单线程收集器比）

**缺点**：

- Stop The World ，目前几乎所有收集器工作时都需要暂停用户线程。



#### ParNew 收集器

Serial 收集器的**多线程**版本，运行在 Server 模式下首选的**新生代收集器**。

除 Serial 收集器外，只有他能与 CMS 收集器配合工作。

单 CPU 环境中，该收集器效率不比 Serial 收集器效率高，由于存在线程切换的开销，即使多个 CPU 也不一定。



#### Parallel Scavenge 收集器

**新生代收集器**，使用**复制算法**，并行的**多线程**收集器。

目标是达到一个可控制的吞吐量，”吞吐量优先“的收集器。

GC 自适应调节策略。


### 老年代收集器
#### Serial Old 收集器

Serial 收集器的**老年代**版本，**单线程**，使用**标记-整理算法**。

主要意义是给 Client 模式下的虚拟机使用。

在 Server 模式下，主要用途：

- 在 JDK 1.5 及以前的版本与 Parallel Scavenge 收集器一起使用。
- 作为 CMS 收集器的后备预案，当发生 Cocurrent Mode Failure 时使用。



#### Parallel Old 收集器

Parallel Scavenge 收集器的**老年代**版本，**多线程**，使用**标记-整理算法**。

在注重吞吐量以及 CPU 资源敏感的场合可以优先考虑 Parallel Scavenge 收集器 加 Parallel Old 收集器。



#### CMS 收集器

CMS （Cocurrent Mark Sweep）收集器，目标是缩短垃圾回收时用户线程暂停的时间。

**老年代收集器**，使用**标记-清除算法**。

**运作过程**：

- 初始标记
- 并发标记
- 重新标记
- 并发清除

初始标记：仅标记一下 GC Roots 能直接关联到的对象，速度快。

并发标记：进行 GC Roots Tracing 的过程：从 GC Roots 开始对对象进行可达性分析，找出存活的对象，这阶段耗时较长。

重新标记：修正在并发标记期间因用户线程继续运行而导致标记产生变动的那一部分对象的标记记录。停顿时间比初始标记阶段长，比并发标记时间短。

并发清除：清除垃圾对象的过程，用户线程继续运作。

**初始标记和重新标记需要STW**（Stop The World）。



**优点：**

- 并发收集，低停顿

**不足**：

- 对 CPU 资源敏感，并发阶段会占用一部分 CPU 资源，导致应用程序变慢，总吞吐量降低；
- 无法处理浮动垃圾，导致 Concurrent Mode Failure 从而导致另一次 Full GC；
- 产生大量空间碎片。



### G1 收集器

面向服务端应用的垃圾收集器。

**特点：**

- **并行与并发**：缩短 STW 时间
- **分代收集**
- **空间整合**：G1 收集器基于标记-整理算法实现。把内存「化整为零」，将Java 堆划分为多个大小相等的独立区域（Region），从局部（两个 Region 之间）来看是基于复制算法实现的。
- **可预测的停顿**：有计划的避免进行全堆垃圾收集。G1 跟踪各个 Region 的垃圾堆积的价值大小，优先回收价值大的 Region。


**Region 划分内存空间以及有优先级的区域回收方式，保证 G1收集器提高回收效率。**



**运作流程：**

- 初始标记
- 并发标记
- 最终标记
- 筛选回收

初始标记，最终标记，筛选回收过程都需要停顿用户线程。

## 内存分配与回收策略

对象主要分配在新生代的 Eden 区上，少数情况下也可能直接分配在老年代中（大对象直接分配在老年代）。

- **对象优先在 Eden 区分配**

  - 大多数情况下对象优先分配在新生代 Eden 区。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。

  - 相关参数：打印内存回收日志：-XX:+PrintGCDetails。

- **大对象直接进入老年代**

  - 大对象指需要大量连续内存空间的 Java 对象。

  - 常见大对象：过长的字符串以及大数组。
  - 经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以提供足够的内存空间来存放大对象。
  - 相关参数：如设置 -XX:PretenureSizeThreshold = 3145728 指令大于 3M 的对象直接进入老年代。

- **长期存活的对象将进入老年代**

  - 对象年龄计数，对象每熬过一次 Minor GC ，年龄加1，到一定年龄(默认 15 岁)，进入老年代。
  - 相关参数：-XX:MaxTenuringThreshold = 1，对象在第二次 Minor GC 时进入老年代。

- **动态年龄判断**

  - 如果在 Survivor 空间中相同年龄的所有对象大小总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就直接进入老年代。

- **空间分配担保**

  - 空间分配担保失败，进行 Full GC。
