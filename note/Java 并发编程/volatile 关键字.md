## volatile 关键字



轻量级的 synchronized，大多数场景下 volatile 的总开销比加锁低。

volatile 关键字可以保证可见性，有序性，但不保证原子性。可以保证 long / double 型变量读写操作的原子性。



### 如何保证可见性

被 volatile 定义的变量，每次修改变量后都必须立即同步至主内存中，每次使用该变量都必须先从主内存刷新最新的值，保证能看见其他线程对该变量所做的修改。

**缓存一致性协议**



### 如何保证有序性

「 内存屏障 」禁止指令重排序。

对于 volatile 变量的写操作，JVM 会在该操作之前插入一个释放屏障，在该操作之后插入一个存储屏障。

```java
a = 1; // 普通变量的读写操作

// Release Barrier. JVM 插入一个内存屏障
volatileVal = true; // volatile 变量的写操作
// Store Barrier. JVM 插入一个内存屏障
```

释放屏障禁止了 volatile 变量的写操作与之前的操作进行重排序，保证了之前的操作会在 volatile 变量的写操作之前提交，即保证了多个线程执行的感知顺序与相应的源代码的顺序一致，即保证了有序性。

存储屏障具有冲刷处理器缓存的作用，因此在 volatile 变量的写操作之后插入一个存储屏障可以使得在存储屏障之前的操作的结果对其他处理器来说是同步的。



对于 volatile 变量的读操作，JVM 会在该操作之前插入一个加载屏障，在该操作之后插入一个获取屏障。

```java
// Load Barrier. JVM 插入一个内存屏障
localVal = volatileVal; // volatile 变量的读操作
// Acquire Barrier. JVM 插入一个内存屏障

b = a; // 普通变量的读写操作
```

加载屏障也具有冲刷处理器缓存的作用

获取屏障禁止了 volatile 变量读操作与之后的其他操作进行重排序。



