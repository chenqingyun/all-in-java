## synchronized 的实现原理与应用



### synchronized 的底层实现

JVM 规范中描述了 synchronized 在 JVM 的实现过程。JVM 基于进入和退出 Monitor 对象来实现方法同步和代码块同步。

代码块同步是使用 **monitorenter** 和 **monitorexit** 指令实现的。方法同步是另一种方式实现的，但也可以用这两个指令实现。

monitorenter 指令是在编译后插入到同步代码块开始的位置，monitorexit 指令是插入到代码块结束处和异常处，JVM 要保证每个 monitorenter 必须要有对应的 monitorexit 与之配对。任何对象都有一个 monitor 与之关联，当一个 monitor 被持有后，它将处于锁定状态。线程执行到 monitorenter 指令时，将会尝试获取对象对应的 monitor 的所有权，即尝试获得对象的锁。



同步方法是依靠方法修饰符上的 「 ACC_SYNCHRONIZED 」来实现的。无论哪种方式，其本质都是对一个对象的监视器 （monitor）进行获取，而这个获取过程是排他的，也就是同一时刻只有一个线程能获取到由 synchronized 所保护的监视器。

没有获得监视器的线程将会被阻塞在同步块或同步方法的入口，进入同步队列，线程状态变为 BLOCKED 状态。当获得锁的线程释放了锁，则该释放操作唤醒阻塞在同步队列中的线程，使其重新尝试对监视器的获取。

![image](https://user-images.githubusercontent.com/19634532/60752762-1d14fb00-9ffc-11e9-9ef8-6f74d1872598.png)

### 锁存在哪里？锁里面存储什么信息？

Java 中的每一个对象都可以作为锁

- 对于普通同步方法，锁是当前对象实例。
- 对于静态同步方法，锁是当前类的 Class 对象。
- 对于同步代码块，锁是 synchronized 括号里配置的对象。



synchronize 用的锁是存在 Java 对象头里的。

[深入理解多线程（一）——Synchronized的实现原理](https://www.hollischuang.com/archives/1883)



### 锁的升级与对比

JDK 1.6 之后，锁有 4 种状态，级别从高到底：**无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态**。

这几种状态会随着线程的竞争情况逐渐升级。锁可以升级但不能降级。



大多数情况下，锁不仅不存在竞争，而且总是由同一个现成获得，为了让线程获得锁的代价更低而引人了「 偏向锁 」。JDK 1.6 后默认启用的是偏向锁。



**锁的优缺点对比**

| 锁       | 优点                                                         | 缺点                                             | 应用场景                           |
| -------- | ------------------------------------------------------------ | ------------------------------------------------ | ---------------------------------- |
| 偏向锁   | 加锁和解锁不需要额外的开销，和执行非同步方法相比仅存在纳秒级的差距 | 如果线程间存在锁竞争，则会带来额外的锁撤销的消耗 | 适用于只有一个线程访问同步块的场景 |
| 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度                     | 如果始终得不到锁竞争的线程，使用自旋会消耗 CPU   | 追求响应时间，同步块执行速度非常快 |
| 重量级锁 | 线程竞争不会使用自旋，不会消耗 CPU                           | 线程阻塞，响应时间慢                             | 追求吞吐量，同步块执行时间较长     |



### 参考

- 《 Java 并发编程的艺术》方腾飞 魏鹏 程晓玥 著
- [聊聊并发（二）Java SE1.6中的Synchronized](http://ifeve.com/java-synchronized/)
- [JVM源码分析之synchronized实现](https://www.jianshu.com/p/c5058b6fe8e5)