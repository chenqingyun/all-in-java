# Thread 源码解读

[TOC]
> 源码基于 JDK 1.8



Thread 类位于 java.lang 包，实现 Runnable 接口。


## Thread 的属性
Thread 的属性包括 id、名称（name）、线程类别（daemon）和优先级（priority）等。

源码如下：

```java
/* 线程的名称 */
private volatile String name;

/* 线程的优先级 */
private int            priority;
private Thread         threadQ;
private long           eetop;

/* Whether or not to single_step this thread. */
private boolean     single_step;

/* 线程是否为守护线程 */
private boolean     daemon = false;

/* JVM state */
private boolean     stillborn = false;

/* 将会被执行的 Runnable */
private Runnable target;

/* 线程组 */
private ThreadGroup group;

/* The context ClassLoader for this thread */
private ClassLoader contextClassLoader;

/* The inherited AccessControlContext of this thread */
private AccessControlContext inheritedAccessControlContext;

/* 第几个线程，给匿名线程自动编号 */
private static int threadInitNumber;
private static synchronized int nextThreadNum() {
    return threadInitNumber++;
}

/* ThreadLocal values pertaining to this thread. This map is maintained
* by the ThreadLocal class. */
ThreadLocal.ThreadLocalMap threadLocals = null;

/*
* InheritableThreadLocal values pertaining to this thread. This map is
* maintained by the InheritableThreadLocal class.
*/
ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;

/* 该线程请求的堆栈大小，未指定大小默认是 0。一些虚拟机是忽略的 */
private long stackSize;

/*
     * JVM-private state that persists after native thread termination.
     */
private long nativeParkEventPointer;

/* 线程 ID */
private long tid;

/* 生成 thread ID */
private static long threadSeqNumber;

/* 标识线程的状态，默认初始化线程是未启动状态 */

private volatile int threadStatus = 0;

volatile Object parkBlocker;

/* 可中断的阻断*/
private volatile Interruptible blocker;

/* 阻断锁*/
private final Object blockerLock = new Object();

/* 线程最小优先级 */
public final static int MIN_PRIORITY = 1;

/* 线程默认优先级 */
public final static int NORM_PRIORITY = 5;

/* 线程最大优先级 */
public final static int MAX_PRIORITY = 10;

/* 线程的状态 */
public enum State {
    NEW,
    RUNNABLE,
    BLOCKED,
    WAITING,
    TIMED_WAITING,
    TERMINATED;
}
```



### 线程的 ID

```java
/*
* Thread ID
*/
private long tid;
```

线程的 ID 是只读的，通过 ``Thread.getId()``方法获取，用于标识不同的线程。

不同的线程有不同 的 ID，但 ID 的唯一性只在 Java 虚拟机的一次运行有效，重启 Java 虚拟机（如重启 Web 服务器）某些线程的 ID 可能与上一次线程的 ID 一样，因此该属性值不适用于做某种唯一标识，如数据库的唯一标识。



### 线程的名称

```java
private volatile String name;
```

每个线程都有一个用于识别目的的名称。 多个线程可能具有相同的名称。 如果在创建线程时未指定名称，则会为其生成一个默认的名称。

查看源码可知其命名方式为 ``Thread-nextThreadNum()``，

```java
public Thread() {
    init(null, null, "Thread-" + nextThreadNum(), 0);
}
```

``nextThreadNum()``方法实现如下：

```java
/* 第几个线程，给匿名线程自动编号 */
private static int threadInitNumber;
private static synchronized int nextThreadNum() {
    return threadInitNumber++;
}
```

通过 ``getName()``方法获取线程名称，打印查看下：

```java
public class ThreadDemo {
    public static void main(String[] args) {
        MyRunnable myRunnable = new MyRunnable();
        Thread thread1= new Thread(myRunnable);
        Thread thread2= new Thread(myRunnable);
        thread1.start();
        thread2.start();
    }

    private static class MyRunnable implements Runnable {
        @Override
        public void run() {
            System.out.println("Thread name:" + Thread.currentThread().getName());
        }
    }
}
```

打印结果：

![](https://upload-images.jianshu.io/upload_images/3297676-5f7d47bd3f00216e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



如何给线程命名呢？可以通过 ``setName()``方法给线程赋予名称，或通过``Thread(Runnable target, String name)``构造器传入。修改代码如下：

```java
MyRunnable myRunnable = new MyRunnable();
Thread thread1= new Thread(myRunnable,"thread1");
Thread thread2= new Thread(myRunnable);
thread2.setName("thread2");
thread1.start();
thread2.start();
```



**建议：为每个线程设置有意义的名称，有利于程序调试和问题定位。**



### 线程优先级

```java
private int priority;
```

每个线程都有优先级，其本质上就是给线程调度器的提示，较高优先级的线程优先于优先级较低的线程执行。

线程有 1~10 的10个优先级，默认为5。

```java
/* 线程最小优先级 */
public final static int MIN_PRIORITY = 1;

/* 线程默认优先级 */
public final static int NORM_PRIORITY = 5;

/* 线程最大优先级 */
public final static int MAX_PRIORITY = 10;
```

线程优先级高仅仅表示线程获取的CPU时间片的几率高，并不能保证优先级高的线程就会优先得到执行。

可以通过 ``setPriority``方法给线程设置优先级，一般情况下使用默认优先级即可，不恰当的设置优先级可能导致严重的问题**（线程饥饿）**。（TODO ？？？）



### 守护线程和用户线程

按照线程是否会阻止 Java 虚拟机运行正常停止，可以将线程分为**守护线程**（Daemon Thread）和**用户线程**（User Thread，也称非守护线程）。

- 父线程为守护线程，则子线程也为守护线程。

线程的 daemon 属性

```java
/* 线程是否为守护线程 */
private boolean daemon = false;
```

可以设置该线程是否为守护线程，true 表示守护线程，false 则表示是普通线程即用户线程。

来写一段代码测试一下守护线程是怎样的：

```java
public class DaemonThread {
    public static void main(String[] args) {
        Thread thread1 = new Thread() {
            @Override
            public void run() {
                int i = 0;
                while (i <= 100000) {
                    System.out.println("this is thread1，" + i);
                    i++;
                }
            }
        };
        // 设置 threa1 为守护线程
        thread1.setDaemon(true);
        thread1.start();

        Thread thread2 = new Thread() {
            @Override
            public void run() {
                System.out.println("this is thread2");
            }
        };
        thread2.start();

    }
}
```

如上代码，按理说，thread1 应该会打印到 100000 的，但是执行了几次打印结果都没有到 100000

![](https://upload-images.jianshu.io/upload_images/3297676-c0b35d4ad9b54e6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

就是因为这里设置了 thread1 为守护线程，在 thread2 和主线程都执行完了，Java 虚拟机就正常停止，thread1 守护线程就不执行了。

所以**守护线程和用户线程的区别**：

- 用户线程会阻止 Java 虚拟机的正常停止，当 Java 虚拟机中所有的用户线程都结束运行了，Java 虚拟机才能正常停止（除非 Java 虚拟机被强制停止）。
- 守护线程不会影响 Java 虚拟机的正常停止，即应用程序中有守护线程还在执行也不影响 Java 虚拟机正常停止。当所有用户线程执行结束，Java 虚拟机停止，守护线程也就停止了。守护线程通常用于执行重要性不高的任务，常用于为其他线程提供服务，如计时线程、监视其他线程的运行情况等。



需要注意的一点是，该属性必须在**线程启动之前设置**，即 setDaemon 方法必须在 start 方法之前调用，否则 setDaemon 方法会抛出 java.lang.IllegalThreadStateException 异常。

看下 setDaemon 的具体实现：

```java
public final void setDaemon(boolean on) {
    checkAccess();
    if (isAlive()) {
        throw new IllegalThreadStateException();
    }
    daemon = on;
}
```



### 线程的状态

线程有 6 种状态：

```java
public enum State {
    /**
    * Thread state for a thread which has not yet started.
    */
    NEW,

    /**
    * Thread state for a runnable thread.  A thread in the runnable
    * state is executing in the Java virtual machine but it may
    * be waiting for other resources from the operating system
    * such as processor.
    */
    RUNNABLE,

    /**
    * Thread state for a thread blocked waiting for a monitor lock.
    * A thread in the blocked state is waiting for a monitor lock
    * to enter a synchronized block/method or
    * reenter a synchronized block/method after calling
    * {@link Object#wait() Object.wait}.
    */
    BLOCKED,

    /**
    * Thread state for a waiting thread.
    * A thread is in the waiting state due to calling one of the
    * following methods:
    * <ul>
    *   <li>{@link Object#wait() Object.wait} with no timeout</li>
    *   <li>{@link #join() Thread.join} with no timeout</li>
    *   <li>{@link LockSupport#park() LockSupport.park}</li>
    * </ul>
    *
    * <p>A thread in the waiting state is waiting for another thread to
    * perform a particular action.
    *
    * For example, a thread that has called <tt>Object.wait()</tt>
    * on an object is waiting for another thread to call
    * <tt>Object.notify()</tt> or <tt>Object.notifyAll()</tt> on
    * that object. A thread that has called <tt>Thread.join()</tt>
    * is waiting for a specified thread to terminate.
    */
    WAITING,

    /**
    * Thread state for a waiting thread with a specified waiting time.
    * A thread is in the timed waiting state due to calling one of
    * the following methods with a specified positive waiting time:
    */
    TIMED_WAITING,

    /**
    * Thread state for a terminated thread.
    * The thread has completed execution.
    */
    TERMINATED;
}
```

- NEW：新创建状态，线程尚未启动。一个线程只能被启动一次，所以一个线程只能有一次处于这个状态。
- RUNNABLE：可运行状态。调用 start 方法后，线程就处于 RUNNABLE 状态。处于该状态的线程可能正在运行，也有可能还未运行在线程池中等待线程调度器的调度。
- BLOCKED：被阻塞状态。被阻塞等待监视器锁定的线程处于此状态。
- WAITING：等待状态。正在等待另一个线程执行特定动作的线程处于此状态。
- TIMED_WAITING：计时等待状态。具有指定等待时间的等待线程的线程状态。
- TERMINATED：被终止状态。已执行结束或因异常而终止的线程处于该状态。

线程的生命周期的详细分析见后续文章~~



## Thread 的构造器



## Thread 的方法