[TOC]

多线程的实现有三种方式：
- 继承 Thread 类
- 实现 Runnable 接口
- 通过 Callable 和 Future 创建线程



## 继承 Thread 类

> Thread 类位于 java.lang 包下，实现 Runnable 接口



**实现步骤：**

- 自定义类继承 Thread 类；

- 子类中重写 Thread 类的 run 方法；

- 创建 Thread 子类的对象，创建线程；

- 调用 start 方法运行线程。

  

**代码示例：**

1. 创建自定义类继承 Thread 类，子类中重写 Thread 类的 run 方法。

```java
public class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("hello," + Thread.currentThread().getName());
    }
}
```

2. 创建 Thread 子类对象，创建线程，调用 start 方法运行线程。
```java
public class ThreadDemo {
    public static void main(String[] args){
        // 创建线程
        MyThread myThread = new MyThread();
        // 设置线程的名称
        myThread.setName("Thread sir");
        // 运行线程，调用 run 方法，打印结果"hello,Thread sir"
        myThread.start();
    }
}
```



**PS：创建匿名子类的形式**

```java
Thread thread = new Thread(){
    public void run() {
        System.out.println("this is my thread");
    }
};
thread.start();
```



## 实现 Runnable 接口
> Runnable 接口位于 java.lang 包下



**实现步骤：**

- 自定义类实现 Runnable 接口；
- 重写 run 方法；
- 创建实现类的对象；
- 创建 Thread 类的对象，将实现类对象作为构造参数传递进去；
- 调用 start 方法运行线程。



**代码示例：**

1. 创建一个类实现 Runnable 接口并重写 run 方法。
```java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("hello," + Thread.currentThread().getName());
    }
}
```

2. 创建 Runnable 实现类的对象，创建 Thread 类的对象，将实现类对象作为构造参数传递进去，调用 start 方法运行线程。

```java
public class RunnableDemo {
    public static void main(String[] args) {
        // 创建 Runnable 实现类的对象
        MyRunnable myRunnable = new MyRunnable();

        // 创建 Thread 类的对象，将实现类对象作为构造参数传递进去
        Thread thread = new Thread(myRunnable);
        // 设置线程名称
        thread.setName("Runnable sir");

        // 调用 start 方法运行线程
        thread.start();
    }
}
```



**PS：创建实现 Runnable 接口的匿名类**

```java
Runnable runnable = new Runnable() {
    @Override
    public void run() {
        System.out.println("this is my thread");
    }
};
Thread thread = new Thread(runnable);
thread.start();
```



## 继承 Thread 和实现 Runnable 的区别

- 面向对象编程的角度：实现 Runnable 的形式比继承 Thread 的形式更加灵活，避免了 Java 单继承的局限性。

- 对象共享的角度：实现 Runnable 的创建方式可以共享同一个 Runnable 实例，可适用于多个相同的程序代码的线程去处理同一个资源。
- 线程池只能放入实现 Runnable 或 Callable 类线程，不能直接放入继承 Thread 的类。
- 如果只想重写 run 方法，而不重写其他 Thread 方法，那么应使用 Runnable 接口。



## run 方法和 start 方法

### run 方法

run 方法相当于线程的任务处理入口，任务的处理逻辑在 run 方法中实现。run 方法由 Java 虚拟机在运行线程时调用，而不是在代码中直接调用 run 方法来执行线程任务。

如下代码：

```java
public class ThreadDemo {
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.setName("Thread sir");
        myThread.run(); 
    }
}
```

打印结果是 “hello,main” ，并不是“hello,Thread sir”。所以只是调用 run 方法，线程是没有启动的，就是在主线程中以普通的方法进行调用。

run 方法执行结束包括正常结束和因抛出异常而导致终止，run 方法执行结束该线程的运行就结束了，线程所占用的资源（如内存空间）也会被 Java 虚拟机垃圾回收机制回收从而得到释放。



### start 方法

一个线程的运行过程是通过 Thread 类的 start 方法启动线程，然后由 Java 虚拟机去调用运行中的线程的 run 方法，从而使相应线程的任务处理逻辑代码得到执行。

启动一个线程的实质是请求 Java 虚拟机运行该线程，而这个线程何时能运行是由线程调度器（Scheduler，操作系统的一部分）决定。因此不是调用 start 方法启动了线程，线程就开始运行了，该线程只是处于可运行状态（Runnable），稍后再运行，但也有可能永远不会被运行。

一个已经结束运行的线程不能通过再次调用 start 方法让其重新运行。重复调用一个线程的 start 方法会抛出“java.lang.IllegalThreadStateException" 异常。



### run 方法和 start 方法区别

- run 方法就是封装被线程执行的代码，直接调用是普通方法。
- start 方法首先启动了线程，然后再由 JVM 去调用该线程的 run 方法。



## 通过 Callable 和 Future 创建线程
创建线程的第三种方式是通过 Callable 和 Future 创建线程。
> 1、public interface Callable<V> 接口位于 java.util.concurrent 包下
> 2、Callable 与 Runnable 类似，但是有返回值
> 3、Callable 接口是一个参数化类型，只有一个方法 call



**实现步骤：**

- 创建 Callable 接口的实现类，并实现 call 方法；

- 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象；

- 创建 Thread 类的对象，将 FutureTask 类的对象作为构造参数传递进去；

- 调用 start 方法运行线程；

- 调用 FutureTask 类的对象的 get 方法来获得子线程执行结束后的返回值；



**代码示例：**
1. 创建 Callable 接口的实现类，并实现 call 方法。该 call 方法将作为线程执行体，并且有返回值。
```
public class MyCallable implements Callable<String>{

    @Override
    public String call() throws Exception {
        return Thread.currentThread().getName();
    }
}
```


2. 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call 方法的返回值；创建 Thread 类的对象，将 FutureTask 类的对象作为构造参数传递进去；调用 start 方法运行线程；调用 FutureTask 类的对象的 get 方法来获得子线程执行结束后的返回值。
```java
public class ThreadDemo {
    public static void main(String[] args){
    
        // 创建 Callable 实现类对象，构造 FutureTask 对象
        MyCallable myCallable = new MyCallable();
        FutureTask<String> futureTask = new FutureTask<String>(myCallable);
        
        // 创建线程
        Thread thread = new Thread(futureTask);
        thread.start();
        
        try {
            // 调用 get 方法获取 call 方法返回值
            System.out.println(futureTask.get());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }
}
```

