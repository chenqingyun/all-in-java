## 原子性、可见性、有序性



### 缓存导致可见性问题

**一个线程对一个共享变量的修改，另一个线程能立刻看到，这称为可见性。**

Java 内存模型规定所有的变量都存储在主内存中。每条线程都有自己的工作内存，保存了被该线程使用到的变量的主内存副本拷贝 ，线程对变量的读取都在工作内存中进行。不同线程之间无法访问对方工作内存中的变量，即不可见。



### 线程切换导致原子性问题

**把一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性**。

```java
i ++;
```

至少需要三条 CPU 指令：

- 把变量 i 从内存加载到 CPU 的寄存器；
- 在寄存器中执行 ``+1`` 操作；
- 最后，结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。

操作系统做任务切换，可以发生在任何一条 **CPU 指令** 执行完。

我们需要在高级语言层面保证操作的原子性。



### 编译期优化导致有序性问题

**有序性指的是程序按照代码的先后顺序执行**。

编译器为了优化性能，有时候会改变程序中语句的先后顺序。



经典案例：利用双重检查创建单例对象。



### 如何保证可见性、原子性、有序性

定义 volatile 变量可以保证可见性，有序性，但不保证原子性。

使用 CAS 操作，加锁可以保证原子性。

