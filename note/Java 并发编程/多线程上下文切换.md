## 多线程上下文切换

### 目录

- [什么是线程上下文切换](#什么是线程上下文切换)
- [什么情况下会引起上下文切换](#什么情况下会引起上下文切换)
- [上下文切换有哪些开销](#上下文切换有哪些开销)
- [如何减少上下文切换导致额外的开销](#如何减少上下文切换导致额外的开销)

### 什么是线程上下文切换

CPU 通过给每个线程分配时间片来循环执行线程任务，当一个线程时间片用完了或其他原因，会被剥夺处理器的使用权而暂停运行，然后会切换到另一个线程执行任务。但是在切换前会保存上一个任务的状态和进度，以便在切回这个任务的时候可以知道上次这个任务执行到哪里了。这里的任务的进度信息就是「 上下文（ context ） 」。这样一个过程就叫做「 线程上下文切换 」。上下文切换会影响多线程的效率。



### 什么情况下会引起上下文切换

自发性上下文切换：

- 当前执行任务碰到阻塞性（ Blocking ） IO，调度器将此任务挂起，继续下一任务。
- 多个任务抢占锁资源，当前任务没有抢到锁资源需要等待获取锁，被调度器挂起，继续下一任务。
- 调用另外 sleep、wait、join、yield 方法等。



非主动性上下文切换：

- 当前执行任务的时间片用完之后，系统 CPU 正常调度下一个任务。
- 垃圾回收过程会 STW。



### 上下文切换有哪些开销

直接开销：

- 操作系统保存和恢复上下文所需的开销，这主要是处理器的时间开销。
- 线程调度器进行线程调度的开销。



间接开销：

- 处理器高速缓存重新加载的开销。
- 上下文切换也可能导致一级高速缓存中的内容被冲刷（ Flush ）。



### 如何减少上下文切换导致额外的开销

减少上下文切换的方法有无锁并发编程、CAS 算法、避免创建过多的线程和使用协程。

- **无锁并发编程**。多线程竞争时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的 ID 按照 Hash 取模分段，不同的线程处理不同段的数据。
- **CAS算法**。Java 的 java.util.concurrent.atomic 包提供了一系列的原子性操作的基本数据类型，使用 CAS 算法来更新数据，而不需要加锁。
- **避免创建过多的线程**。如任务量少时，尽可能减少创建线程。对于某个时间段任务量很大的这种情况，我们可以通过线程池来管理线程的数量，避免创建过多线程。
- **协程**。在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。



todo

- Hash 取模
- CAS 算法实现原理