## RabbitMQ 消息丢失问题



### 什么情况下消息会丢失？

- **RabbitMQ 弄丢消息**：队列和消息都没有设置持久化，在 RabbitMQ 服务重启之后，队列会丢失，消息自然也就丢失了。不过，就算开启了持久化，RabbitMQ 也有可能还未持久化时挂掉，导致消息丢失。
- **生产者弄丢消息**：生产者将数据发送到 RabbitMQ 的时候，可能数据就在半路给搞丢了。
- **消费者弄丢消息**：如果在订阅消费队列时将 autoACK 参数设置为 true，那么当消费者接收到消息之后还没来得及处理就宕机了，由于开启了自动 ACK ，RabbitMQ 会认为消息已消费，删掉消息。



### 如何保证消息不丢失？

- 队列和消息开启持久化，关闭自动 ACK，以解决服务器崩溃或消费者宕机而导致的消息丢失。
- 在发送端引入「 事务机制 」或者「 发送方确认机制 」保证消息已经发送并存储至 RabbitMQ 中。
- 引入 RabbitMQ 的镜像队列机制，相当于配置了副本，如果 master 挂掉，可以自动切换到 slave，这样有效地保证了高可用。



#### 事务机制

生产者发送数据之前通过 `channel.txSelect` 开启 RabbitMQ 事务，然后发送消息，如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错，此时就可以回滚事务 `channel.txRollback`，然后重试发送消息；如果收到了消息，那么可以提交事务 `channel.txCommit`。



但是 RabbitMQ 事务机制太耗性能，基本上吞吐量会下来。



#### 发送方确认机制

发送方确认（publisher confirm）机制，一种轻量级的方式。

生产者将 channel 设置为 confirm 模式，所有在这个 channel 上发布的消息都会被指派一个唯一 ID，如果消息投递到匹配的队列了，RabbitMQ 就会发送 ACK 给生产者，表示收到消息了。

如果消息和队列设置了持久化，那么确认消息将在消息写入磁盘后发出。



事务机制和发送方确认机制的不同：

- 事务机制是同步的，在一条消息发送之后会使发送端阻塞，以等待 RabbitMQ 的回应。
- 确认机制是异步的，在一条消息发送之后可以在等待 ACK 的时候发下一条消息，然后那个消息 RabbitMQ 接收了之后通过异步回调通知消息接收到了。



### 消息丢失了如何补偿？

在消息发送、接受时记录 DB 日志，定时轮训 DB 日志，查明哪些发送消息没有成功消费，启动重新发送消息机制。

